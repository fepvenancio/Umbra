import { describe, it, expect, beforeAll } from "bun:test";

// Contract artifact - generated by aztec-nargo compile
import UmbraEscrowArtifact from "../target/umbra_escrow-UmbraEscrow.json";
import UmbraPoolArtifact from "../target/umbra_pool-UmbraPool.json";

describe("UmbraEscrow Contract Artifact", () => {
  describe("Structure Validation", () => {
    it("should have valid contract artifact", () => {
      expect(UmbraEscrowArtifact).toBeDefined();
      expect(UmbraEscrowArtifact.name).toBe("UmbraEscrow");
    });

    it("should have all required functions", () => {
      const functionNames = UmbraEscrowArtifact.functions.map((f: any) => f.name);

      // Core functions
      expect(functionNames).toContain("constructor");
      expect(functionNames).toContain("create_order");
      expect(functionNames).toContain("fill_order");
      expect(functionNames).toContain("cancel_order");

      // Admin functions
      expect(functionNames).toContain("set_fee");
      expect(functionNames).toContain("set_fee_recipient");
      expect(functionNames).toContain("pause");
      expect(functionNames).toContain("unpause");

      // View functions
      expect(functionNames).toContain("get_admin");
      expect(functionNames).toContain("get_fee_bps");
      expect(functionNames).toContain("get_fee_recipient");
      expect(functionNames).toContain("get_order_count");
      expect(functionNames).toContain("get_total_volume");
      expect(functionNames).toContain("is_paused");
      expect(functionNames).toContain("order_exists");
      expect(functionNames).toContain("is_order_filled");
    });

    it("should have private create_order function", () => {
      const createOrder = UmbraEscrowArtifact.functions.find((f: any) => f.name === "create_order");
      expect(createOrder).toBeDefined();
      expect(createOrder.custom_attributes).toContain("private");
    });

    it("should have private fill_order function", () => {
      const fillOrder = UmbraEscrowArtifact.functions.find((f: any) => f.name === "fill_order");
      expect(fillOrder).toBeDefined();
      expect(fillOrder.custom_attributes).toContain("private");
    });

    it("should have private cancel_order function", () => {
      const cancelOrder = UmbraEscrowArtifact.functions.find((f: any) => f.name === "cancel_order");
      expect(cancelOrder).toBeDefined();
      expect(cancelOrder.custom_attributes).toContain("private");
    });

    it("should have internal functions for state updates", () => {
      const functionNames = UmbraEscrowArtifact.functions.map((f: any) => f.name);
      expect(functionNames).toContain("_store_order");
      expect(functionNames).toContain("_process_fill");
      expect(functionNames).toContain("_process_cancel");
    });
  });

  describe("Order Logic Tests", () => {
    it("should validate positive amounts", () => {
      const sellAmount = 100n;
      const buyAmount = 3500n;
      expect(sellAmount > 0n).toBe(true);
      expect(buyAmount > 0n).toBe(true);
    });

    it("should reject zero amounts", () => {
      const zeroAmount = 0n;
      expect(zeroAmount > 0n).toBe(false);
    });

    it("should generate unique escrow IDs", () => {
      const id1 = BigInt("0x" + Math.random().toString(16).slice(2, 18));
      const id2 = BigInt("0x" + Math.random().toString(16).slice(2, 18));
      expect(id1).not.toBe(id2);
    });
  });

  describe("Order Filling Logic", () => {
    it("should validate order exists before fill", () => {
      const orders: Record<string, boolean> = { "order-1": true };
      expect(orders["order-1"]).toBe(true);
      expect(orders["order-2"]).toBeUndefined();
    });

    it("should prevent self-fill", () => {
      const seller = "0x1111111111111111111111111111111111111111";
      const buyer = "0x2222222222222222222222222222222222222222";
      expect(seller !== buyer).toBe(true);
    });

    it("should prevent double-fill", () => {
      const orderFilled: Record<string, boolean> = {};
      orderFilled["order-1"] = true;
      const canFillAgain = !orderFilled["order-1"];
      expect(canFillAgain).toBe(false);
    });
  });

  describe("Fee Calculation", () => {
    it("should calculate fees correctly at 0.3%", () => {
      const amount = 10000n;
      const feeBps = 30n;
      const fee = (amount * feeBps) / 10000n;
      expect(fee).toBe(30n);
    });

    it("should calculate fees correctly at 1%", () => {
      const amount = 10000n;
      const feeBps = 100n;
      const fee = (amount * feeBps) / 10000n;
      expect(fee).toBe(100n);
    });

    it("should enforce max fee of 1%", () => {
      const maxFeeBps = 100n;
      const validFee = 50n;
      const invalidFee = 150n;
      expect(validFee <= maxFeeBps).toBe(true);
      expect(invalidFee <= maxFeeBps).toBe(false);
    });

    it("should calculate amount after fee correctly", () => {
      const amount = 10000n;
      const feeBps = 30n;
      const fee = (amount * feeBps) / 10000n;
      const amountAfterFee = amount - fee;
      expect(amountAfterFee).toBe(9970n);
    });
  });
});

describe("UmbraPool Contract Artifact", () => {
  describe("Structure Validation", () => {
    it("should have valid contract artifact", () => {
      expect(UmbraPoolArtifact).toBeDefined();
      expect(UmbraPoolArtifact.name).toBe("UmbraPool");
    });

    it("should have all required functions", () => {
      const functionNames = UmbraPoolArtifact.functions.map((f: any) => f.name);

      // Core functions
      expect(functionNames).toContain("constructor");
      expect(functionNames).toContain("submit_market_order");
      expect(functionNames).toContain("submit_limit_order");
      expect(functionNames).toContain("match_orders");
      expect(functionNames).toContain("cancel_order");

      // Pair management
      expect(functionNames).toContain("add_pair");
      expect(functionNames).toContain("remove_pair");
      expect(functionNames).toContain("is_pair_supported");

      // Admin functions
      expect(functionNames).toContain("set_oracle");
      expect(functionNames).toContain("set_taker_fee");
      expect(functionNames).toContain("set_maker_fee");
      expect(functionNames).toContain("pause");
      expect(functionNames).toContain("unpause");

      // View functions
      expect(functionNames).toContain("get_admin");
      expect(functionNames).toContain("get_oracle");
      expect(functionNames).toContain("get_order_count");
      expect(functionNames).toContain("get_total_volume");
      expect(functionNames).toContain("get_total_matches");
    });

    it("should have private order submission functions", () => {
      const submitMarket = UmbraPoolArtifact.functions.find((f: any) => f.name === "submit_market_order");
      const submitLimit = UmbraPoolArtifact.functions.find((f: any) => f.name === "submit_limit_order");
      const matchOrders = UmbraPoolArtifact.functions.find((f: any) => f.name === "match_orders");

      expect(submitMarket?.custom_attributes).toContain("private");
      expect(submitLimit?.custom_attributes).toContain("private");
      expect(matchOrders?.custom_attributes).toContain("private");
    });
  });

  describe("Order Matching Logic", () => {
    it("should match when buy price >= sell price", () => {
      const buyOrder = { side: "BUY", base: "WETH", quote: "USDC", limitPrice: 3500n };
      const sellOrder = { side: "SELL", base: "WETH", quote: "USDC", limitPrice: 3400n };

      expect(buyOrder.limitPrice >= sellOrder.limitPrice).toBe(true);
      expect(buyOrder.base === sellOrder.base).toBe(true);
      expect(buyOrder.quote === sellOrder.quote).toBe(true);
    });

    it("should reject when buy price < sell price", () => {
      const buyOrder = { side: "BUY", limitPrice: 3000n };
      const sellOrder = { side: "SELL", limitPrice: 3500n };

      expect(buyOrder.limitPrice >= sellOrder.limitPrice).toBe(false);
    });

    it("should identify market orders (limit_price = 0)", () => {
      const marketBuy = { side: "BUY", limitPrice: 0n };
      const isMarketOrder = marketBuy.limitPrice === 0n;
      expect(isMarketOrder).toBe(true);
    });
  });

  describe("Partial Fill Logic", () => {
    it("should calculate remaining amount correctly", () => {
      const totalAmount = 1000n;
      const filledAmount = 400n;
      const remaining = totalAmount - filledAmount;
      expect(remaining).toBe(600n);
    });

    it("should mark order complete when fully filled", () => {
      const totalAmount = 1000n;
      const filledAmount = 1000n;
      const isComplete = filledAmount >= totalAmount;
      expect(isComplete).toBe(true);
    });

    it("should calculate match amount as min of both orders", () => {
      const buyRemaining = 500n;
      const sellRemaining = 300n;
      const matchAmount = buyRemaining < sellRemaining ? buyRemaining : sellRemaining;
      expect(matchAmount).toBe(300n);
    });
  });

  describe("Fee Structure", () => {
    it("should apply taker and maker fees correctly", () => {
      const quoteAmount = 10000n;
      const baseAmount = 1000n;
      const takerFeeBps = 30n;
      const makerFeeBps = 10n;

      const takerFee = (quoteAmount * takerFeeBps) / 10000n;
      const makerFee = (baseAmount * makerFeeBps) / 10000n;

      expect(takerFee).toBe(30n);
      expect(makerFee).toBe(1n);
    });

    it("should enforce max fees of 1%", () => {
      const maxFeeBps = 100n;
      expect(30n <= maxFeeBps).toBe(true);
      expect(10n <= maxFeeBps).toBe(true);
      expect(150n <= maxFeeBps).toBe(false);
    });
  });

  describe("Price Calculation", () => {
    it("should calculate quote amount from base and price", () => {
      const baseAmount = 1000000000000000000n; // 1e18 (1 token)
      const price = 3500000000000000000000n;   // 3500e18 ($3500)
      const precision = 1000000000000000000n;  // 1e18

      const quoteAmount = (baseAmount * price) / precision;
      expect(quoteAmount).toBe(3500000000000000000000n);
    });
  });
});
